# **************************************************************************** #
#                                                                              #
#                                                           :::      ::::::    #
#    chapter1.org                                       :+:      :+:    :+:    #
#                                                   +:+ +:+           +:+      #
#    By: yiyuli <yy@eyuan.me>                     +#+  +:+         +#+         #
#                                               +#+#+#+#+#+      +#+           #
#    Created: 2026/02/19 14:16:08 by yiyuli           #+#      #+#             #
#    Updated: 2026/02/19 14:18:05 by yiyuli         ###      ########.fr       #
#                                                                              #
# **************************************************************************** #

#+title:Chapter 1 Building Abstractions with procedures 

* 1.1.6 Conditional Expressions and Predicates

** Exercise 1.2
Translate the following expression into prefix form.

$$\frac{5 + 4 + (2 - (3 - (6 + \frac{4}{5})))}{3(6 - 2)(2 - 7)}$$

#+BEGIN_SRC emacs-lisp
(/ (+ 5
      4
      (- 2
         (- 3
            (+ 6
               (/ 4.0 5)))))
   (* 3
      (- 6 2)
      (- 2 7)))
#+END_SRC

#+RESULTS:
: -0.24666666666666667

** Exercise 1.3
Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.

#+BEGIN_SRC emacs-lisp
(defun square (x) (* x x))

(defun sum-of-squares (a b)
  (+ (square a) (square b)))

(defun sum-of-squares-largest-two (a b c)
  (cond
   ((<= a b c) (sum-of-squares b c))
   ((<= b a c) (sum-of-squares a c))
   (t (sum-of-squares a b))))

(sum-of-squares-largest-two 1 2 3)
#+END_SRC

#+RESULTS:
: 13

** Exercise 1.7
The good-enough? test used in computing square roots will not be very effective for finding the square roots of very small numbers. Also, in real computers, arithmetic operations are almost always performed with limited precision. This makes our test inadequate for very large numbers.

*** The problem with the original approach

The original =good-enough?= checks if =|guessÂ² - x| < 0.001=. This fixed tolerance fails in two ways:

*For small numbers:* If x = 0.0001, the actual square root is 0.01. But our tolerance of 0.001 is 10% of the answer! We might accept 0.03 as "good enough" when it's wildly wrong.

*For large numbers:* If x = 10000000000000 (10^13), floating point precision means we can't represent differences smaller than ~1. The algorithm might never terminate because we can't get within 0.001 of the answer, or it oscillates forever.

#+BEGIN_SRC emacs-lisp
;; Original (broken) implementation
(defun square (x) (* x x))

(defun average (a b) (/ (+ a b) 2.0))

(defun improve (guess x)
  (average guess (/ x guess)))

(defun good-enough? (guess x)
  (< (abs (- (square guess) x)) 0.001))

(defun sqrt-iter (guess x)
  (if (good-enough? guess x)
      guess
    (sqrt-iter (improve guess x) x)))

(defun bad-sqrt (x)
  (sqrt-iter 1.0 x))

;; Test with small number - inaccurate result
(bad-sqrt 0.0001)  ; gives ~0.03, should be 0.01
#+END_SRC

#+RESULTS:
: 0.03230844833048122

*** Improved implementation

#+BEGIN_SRC emacs-lisp
(defun square (x) (* x x))

(defun average (a b) (/ (+ a b) 2.0))

(defun improve (guess x)
  (average guess (/ x guess)))

(defun good-enough? (guess previous-guess)
  (< (abs (- guess previous-guess))
     (* guess 0.00001)))

(defun sqrt-iter (guess previous-guess x)
  (if (good-enough? guess previous-guess)
      guess
    (sqrt-iter (improve guess x) guess x)))

(defun better-sqrt (x)
  (sqrt-iter 1.0 0.0 x))

;; Test both implementations
(list
 (cons "small (0.0001):" (better-sqrt 0.0001))
 (cons "normal (2):" (better-sqrt 2))
 (cons "large (1e13):" (better-sqrt 1e13)))
#+END_SRC

#+RESULTS:
: ((small (0.0001): . 0.01) (normal (2): . 1.4142135623746899) (large (1e13): . 3162277.6601683795))

** Exercise 1.8
Newton's method for cube roots is based on the fact that if y is an approximation to the cube root of x, then a better approximation is given by the value

$$\frac{x/y^2 + 2y}{3}$$

Use this formula to implement a cube-root procedure analogous to the square-root procedure.

#+BEGIN_SRC emacs-lisp
(defun square (x) (* x x))

(defun cube (x) (* x x x))

(defun improve-cube (guess x)
  (/ (+ (/ x (square guess))
        (* 2 guess))
     3.0))

(defun good-enough? (guess previous-guess)
  (< (abs (- guess previous-guess))
     (* (abs guess) 0.00001)))

(defun cbrt-iter (guess previous-guess x)
  (if (good-enough? guess previous-guess)
      guess
    (cbrt-iter (improve-cube guess x) guess x)))

(defun cbrt (x)
  (cbrt-iter 1.0 0.0 x))

(list
 (cons "cbrt(8):" (cbrt 8))
 (cons "cbrt(27):" (cbrt 27))
 (cons "cbrt(1000):" (cbrt 1000))
 (cons "cbrt(0.001):" (cbrt 0.001))
 (cons "cbrt(-8):" (cbrt -8)))
#+END_SRC

#+RESULTS:
: ((cbrt(8): . 2.000000000012062) (cbrt(27): . 3.0000000000000977) (cbrt(1000): . 10.000000000000002) (cbrt(0.001): . 0.10000000000000005) (cbrt(-8): . -2.0))

** Exercise 1.11
A function $f$ is defined by the rule that $f(n) = n$ if $n < 3$ and $f(n) = f(n-1) + 2f(n-2) + 3f(n-3)$ if $n \geq 3$.

*** Recursive Process
#+BEGIN_SRC scheme
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3))))))
#+END_SRC

*** Iterative Process
#+BEGIN_SRC scheme
(define (f n)
  (define (f-iter a b c count)
    (if (< count 3)
        a
        (f-iter (+ a (* 2 b) (* 3 c))
                a
                b
                (- count 1))))
  (if (< n 3)
      n
      (f-iter 2 1 0 n)))

#+END_SRC
